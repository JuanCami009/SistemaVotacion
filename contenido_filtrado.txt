================================================================================
FILE: C:\Users\alexd\Universidad\SextoSemestre\Compunet\SistemaVotacion\reliableServer\build.gradle
--------------------------------------------------------------------------------
slice {
    java {
        files = [file("ReliableMessage.ice")]
    }
}

repositories {
    mavenCentral()
}

dependencies{
    implementation 'com.zeroc:ice:3.7.2'

}


jar {
        manifest {
            attributes(
                "Main-Class": project.name.capitalize(),
                "Class-Path": configurations.runtimeClasspath.resolve().collect { it.toURI() }.join(' ')
            )
        }
    }

================================================================================
FILE: C:\Users\alexd\Universidad\SextoSemestre\Compunet\SistemaVotacion\reliableServer\ReliableMessage.ice
--------------------------------------------------------------------------------
module reliableMessage{

    ["java:serializable:model.ReliableMessage"]
    sequence<byte> RMessage;
    ["java:serializable:model.Message"]
    sequence<byte> Message;


    interface ACKService{
        void ack(string messageId);
    }
    interface RMDestination{
        void reciveMessage(RMessage rmessage, ACKService* prx);
    }
    interface RMSource{
        void setServerProxy(RMDestination* destination);
        void sendMessage(Message msg);
    }

}

================================================================================
FILE: C:\Users\alexd\Universidad\SextoSemestre\Compunet\SistemaVotacion\reliableServer\bin\main\rmservice.config
--------------------------------------------------------------------------------
RMService.Endpoints=tcp -h localhost -p 10010

================================================================================
FILE: C:\Users\alexd\Universidad\SextoSemestre\Compunet\SistemaVotacion\reliableServer\build\generated-src\reliableMessage\ACKService.java
--------------------------------------------------------------------------------
//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.10
//
// <auto-generated>
//
// Generated from file `ReliableMessage.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

package reliableMessage;

public interface ACKService extends com.zeroc.Ice.Object
{
    void ack(String messageId, com.zeroc.Ice.Current current);

    /** @hidden */
    static final String[] _iceIds =
    {
        "::Ice::Object",
        "::reliableMessage::ACKService"
    };

    @Override
    default String[] ice_ids(com.zeroc.Ice.Current current)
    {
        return _iceIds;
    }

    @Override
    default String ice_id(com.zeroc.Ice.Current current)
    {
        return ice_staticId();
    }

    static String ice_staticId()
    {
        return "::reliableMessage::ACKService";
    }

    /**
     * @hidden
     * @param obj -
     * @param inS -
     * @param current -
     * @return -
    **/
    static java.util.concurrent.CompletionStage<com.zeroc.Ice.OutputStream> _iceD_ack(ACKService obj, final com.zeroc.IceInternal.Incoming inS, com.zeroc.Ice.Current current)
    {
        com.zeroc.Ice.Object._iceCheckMode(null, current.mode);
        com.zeroc.Ice.InputStream istr = inS.startReadParams();
        String iceP_messageId;
        iceP_messageId = istr.readString();
        inS.endReadParams();
        obj.ack(iceP_messageId, current);
        return inS.setResult(inS.writeEmptyParams());
    }

    /** @hidden */
    final static String[] _iceOps =
    {
        "ack",
        "ice_id",
        "ice_ids",
        "ice_isA",
        "ice_ping"
    };

    /** @hidden */
    @Override
    default java.util.concurrent.CompletionStage<com.zeroc.Ice.OutputStream> _iceDispatch(com.zeroc.IceInternal.Incoming in, com.zeroc.Ice.Current current)
        throws com.zeroc.Ice.UserException
    {
        int pos = java.util.Arrays.binarySearch(_iceOps, current.operation);
        if(pos < 0)
        {
            throw new com.zeroc.Ice.OperationNotExistException(current.id, current.facet, current.operation);
        }

        switch(pos)
        {
            case 0:
            {
                return _iceD_ack(this, in, current);
            }
            case 1:
            {
                return com.zeroc.Ice.Object._iceD_ice_id(this, in, current);
            }
            case 2:
            {
                return com.zeroc.Ice.Object._iceD_ice_ids(this, in, current);
            }
            case 3:
            {
                return com.zeroc.Ice.Object._iceD_ice_isA(this, in, current);
            }
            case 4:
            {
                return com.zeroc.Ice.Object._iceD_ice_ping(this, in, current);
            }
        }

        assert(false);
        throw new com.zeroc.Ice.OperationNotExistException(current.id, current.facet, current.operation);
    }
}


================================================================================
FILE: C:\Users\alexd\Universidad\SextoSemestre\Compunet\SistemaVotacion\reliableServer\build\generated-src\reliableMessage\ACKServicePrx.java
--------------------------------------------------------------------------------
//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.10
//
// <auto-generated>
//
// Generated from file `ReliableMessage.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

package reliableMessage;

public interface ACKServicePrx extends com.zeroc.Ice.ObjectPrx
{
    default void ack(String messageId)
    {
        ack(messageId, com.zeroc.Ice.ObjectPrx.noExplicitContext);
    }

    default void ack(String messageId, java.util.Map<String, String> context)
    {
        _iceI_ackAsync(messageId, context, true).waitForResponse();
    }

    default java.util.concurrent.CompletableFuture<Void> ackAsync(String messageId)
    {
        return _iceI_ackAsync(messageId, com.zeroc.Ice.ObjectPrx.noExplicitContext, false);
    }

    default java.util.concurrent.CompletableFuture<Void> ackAsync(String messageId, java.util.Map<String, String> context)
    {
        return _iceI_ackAsync(messageId, context, false);
    }

    /**
     * @hidden
     * @param iceP_messageId -
     * @param context -
     * @param sync -
     * @return -
     **/
    default com.zeroc.IceInternal.OutgoingAsync<Void> _iceI_ackAsync(String iceP_messageId, java.util.Map<String, String> context, boolean sync)
    {
        com.zeroc.IceInternal.OutgoingAsync<Void> f = new com.zeroc.IceInternal.OutgoingAsync<>(this, "ack", null, sync, null);
        f.invoke(false, context, null, ostr -> {
                     ostr.writeString(iceP_messageId);
                 }, null);
        return f;
    }

    /**
     * Contacts the remote server to verify that the object implements this type.
     * Raises a local exception if a communication error occurs.
     * @param obj The untyped proxy.
     * @return A proxy for this type, or null if the object does not support this type.
     **/
    static ACKServicePrx checkedCast(com.zeroc.Ice.ObjectPrx obj)
    {
        return com.zeroc.Ice.ObjectPrx._checkedCast(obj, ice_staticId(), ACKServicePrx.class, _ACKServicePrxI.class);
    }

    /**
     * Contacts the remote server to verify that the object implements this type.
     * Raises a local exception if a communication error occurs.
     * @param obj The untyped proxy.
     * @param context The Context map to send with the invocation.
     * @return A proxy for this type, or null if the object does not support this type.
     **/
    static ACKServicePrx checkedCast(com.zeroc.Ice.ObjectPrx obj, java.util.Map<String, String> context)
    {
        return com.zeroc.Ice.ObjectPrx._checkedCast(obj, context, ice_staticId(), ACKServicePrx.class, _ACKServicePrxI.class);
    }

    /**
     * Contacts the remote server to verify that a facet of the object implements this type.
     * Raises a local exception if a communication error occurs.
     * @param obj The untyped proxy.
     * @param facet The name of the desired facet.
     * @return A proxy for this type, or null if the object does not support this type.
     **/
    static ACKServicePrx checkedCast(com.zeroc.Ice.ObjectPrx obj, String facet)
    {
        return com.zeroc.Ice.ObjectPrx._checkedCast(obj, facet, ice_staticId(), ACKServicePrx.class, _ACKServicePrxI.class);
    }

    /**
     * Contacts the remote server to verify that a facet of the object implements this type.
     * Raises a local exception if a communication error occurs.
     * @param obj The untyped proxy.
     * @param facet The name of the desired facet.
     * @param context The Context map to send with the invocation.
     * @return A proxy for this type, or null if the object does not support this type.
     **/
    static ACKServicePrx checkedCast(com.zeroc.Ice.ObjectPrx obj, String facet, java.util.Map<String, String> context)
    {
        return com.zeroc.Ice.ObjectPrx._checkedCast(obj, facet, context, ice_staticId(), ACKServicePrx.class, _ACKServicePrxI.class);
    }

    /**
     * Downcasts the given proxy to this type without contacting the remote server.
     * @param obj The untyped proxy.
     * @return A proxy for this type.
     **/
    static ACKServicePrx uncheckedCast(com.zeroc.Ice.ObjectPrx obj)
    {
        return com.zeroc.Ice.ObjectPrx._uncheckedCast(obj, ACKServicePrx.class, _ACKServicePrxI.class);
    }

    /**
     * Downcasts the given proxy to this type without contacting the remote server.
     * @param obj The untyped proxy.
     * @param facet The name of the desired facet.
     * @return A proxy for this type.
     **/
    static ACKServicePrx uncheckedCast(com.zeroc.Ice.ObjectPrx obj, String facet)
    {
        return com.zeroc.Ice.ObjectPrx._uncheckedCast(obj, facet, ACKServicePrx.class, _ACKServicePrxI.class);
    }

    /**
     * Returns a proxy that is identical to this proxy, except for the per-proxy context.
     * @param newContext The context for the new proxy.
     * @return A proxy with the specified per-proxy context.
     **/
    @Override
    default ACKServicePrx ice_context(java.util.Map<String, String> newContext)
    {
        return (ACKServicePrx)_ice_context(newContext);
    }

    /**
     * Returns a proxy that is identical to this proxy, except for the adapter ID.
     * @param newAdapterId The adapter ID for the new proxy.
     * @return A proxy with the specified adapter ID.
     **/
    @Override
    default ACKServicePrx ice_adapterId(String newAdapterId)
    {
        return (ACKServicePrx)_ice_adapterId(newAdapterId);
    }

    /**
     * Returns a proxy that is identical to this proxy, except for the endpoints.
     * @param newEndpoints The endpoints for the new proxy.
     * @return A proxy with the specified endpoints.
     **/
    @Override
    default ACKServicePrx ice_endpoints(com.zeroc.Ice.Endpoint[] newEndpoints)
    {
        return (ACKServicePrx)_ice_endpoints(newEndpoints);
    }

    /**
     * Returns a proxy that is identical to this proxy, except for the locator cache timeout.
     * @param newTimeout The new locator cache timeout (in seconds).
     * @return A proxy with the specified locator cache timeout.
     **/
    @Override
    default ACKServicePrx ice_locatorCacheTimeout(int newTimeout)
    {
        return (ACKServicePrx)_ice_locatorCacheTimeout(newTimeout);
    }

    /**
     * Returns a proxy that is identical to this proxy, except for the invocation timeout.
     * @param newTimeout The new invocation timeout (in seconds).
     * @return A proxy with the specified invocation timeout.
     **/
    @Override
    default ACKServicePrx ice_invocationTimeout(int newTimeout)
    {
        return (ACKServicePrx)_ice_invocationTimeout(newTimeout);
    }

    /**
     * Returns a proxy that is identical to this proxy, except for connection caching.
     * @param newCache <code>true</code> if the new proxy should cache connections; <code>false</code> otherwise.
     * @return A proxy with the specified caching policy.
     **/
    @Override
    default ACKServicePrx ice_connectionCached(boolean newCache)
    {
        return (ACKServicePrx)_ice_connectionCached(newCache);
    }

    /**
     * Returns a proxy that is identical to this proxy, except for the endpoint selection policy.
     * @param newType The new endpoint selection policy.
     * @return A proxy with the specified endpoint selection policy.
     **/
    @Override
    default ACKServicePrx ice_endpointSelection(com.zeroc.Ice.EndpointSelectionType newType)
    {
        return (ACKServicePrx)_ice_endpointSelection(newType);
    }

    /**
     * Returns a proxy that is identical to this proxy, except for how it selects endpoints.
     * @param b If <code>b</code> is <code>true</code>, only endpoints that use a secure transport are
     * used by the new proxy. If <code>b</code> is false, the returned proxy uses both secure and
     * insecure endpoints.
     * @return A proxy with the specified selection policy.
     **/
    @Override
    default ACKServicePrx ice_secure(boolean b)
    {
        return (ACKServicePrx)_ice_secure(b);
    }

    /**
     * Returns a proxy that is identical to this proxy, except for the encoding used to marshal parameters.
     * @param e The encoding version to use to marshal request parameters.
     * @return A proxy with the specified encoding version.
     **/
    @Override
    default ACKServicePrx ice_encodingVersion(com.zeroc.Ice.EncodingVersion e)
    {
        return (ACKServicePrx)_ice_encodingVersion(e);
    }

    /**
     * Returns a proxy that is identical to this proxy, except for its endpoint selection policy.
     * @param b If <code>b</code> is <code>true</code>, the new proxy will use secure endpoints for invocations
     * and only use insecure endpoints if an invocation cannot be made via secure endpoints. If <code>b</code> is
     * <code>false</code>, the proxy prefers insecure endpoints to secure ones.
     * @return A proxy with the specified selection policy.
     **/
    @Override
    default ACKServicePrx ice_preferSecure(boolean b)
    {
        return (ACKServicePrx)_ice_preferSecure(b);
    }

    /**
     * Returns a proxy that is identical to this proxy, except for the router.
     * @param router The router for the new proxy.
     * @return A proxy with the specified router.
     **/
    @Override
    default ACKServicePrx ice_router(com.zeroc.Ice.RouterPrx router)
    {
        return (ACKServicePrx)_ice_router(router);
    }

    /**
     * Returns a proxy that is identical to this proxy, except for the locator.
     * @param locator The locator for the new proxy.
     * @return A proxy with the specified locator.
     **/
    @Override
    default ACKServicePrx ice_locator(com.zeroc.Ice.LocatorPrx locator)
    {
        return (ACKServicePrx)_ice_locator(locator);
    }

    /**
     * Returns a proxy that is identical to this proxy, except for collocation optimization.
     * @param b <code>true</code> if the new proxy enables collocation optimization; <code>false</code> otherwise.
     * @return A proxy with the specified collocation optimization.
     **/
    @Override
    default ACKServicePrx ice_collocationOptimized(boolean b)
    {
        return (ACKServicePrx)_ice_collocationOptimized(b);
    }

    /**
     * Returns a proxy that is identical to this proxy, but uses twoway invocations.
     * @return A proxy that uses twoway invocations.
     **/
    @Override
    default ACKServicePrx ice_twoway()
    {
        return (ACKServicePrx)_ice_twoway();
    }

    /**
     * Returns a proxy that is identical to this proxy, but uses oneway invocations.
     * @return A proxy that uses oneway invocations.
     **/
    @Override
    default ACKServicePrx ice_oneway()
    {
        return (ACKServicePrx)_ice_oneway();
    }

    /**
     * Returns a proxy that is identical to this proxy, but uses batch oneway invocations.
     * @return A proxy that uses batch oneway invocations.
     **/
    @Override
    default ACKServicePrx ice_batchOneway()
    {
        return (ACKServicePrx)_ice_batchOneway();
    }

    /**
     * Returns a proxy that is identical to this proxy, but uses datagram invocations.
     * @return A proxy that uses datagram invocations.
     **/
    @Override
    default ACKServicePrx ice_datagram()
    {
        return (ACKServicePrx)_ice_datagram();
    }

    /**
     * Returns a proxy that is identical to this proxy, but uses batch datagram invocations.
     * @return A proxy that uses batch datagram invocations.
     **/
    @Override
    default ACKServicePrx ice_batchDatagram()
    {
        return (ACKServicePrx)_ice_batchDatagram();
    }

    /**
     * Returns a proxy that is identical to this proxy, except for compression.
     * @param co <code>true</code> enables compression for the new proxy; <code>false</code> disables compression.
     * @return A proxy with the specified compression setting.
     **/
    @Override
    default ACKServicePrx ice_compress(boolean co)
    {
        return (ACKServicePrx)_ice_compress(co);
    }

    /**
     * Returns a proxy that is identical to this proxy, except for its connection timeout setting.
     * @param t The connection timeout for the proxy in milliseconds.
     * @return A proxy with the specified timeout.
     **/
    @Override
    default ACKServicePrx ice_timeout(int t)
    {
        return (ACKServicePrx)_ice_timeout(t);
    }

    /**
     * Returns a proxy that is identical to this proxy, except for its connection ID.
     * @param connectionId The connection ID for the new proxy. An empty string removes the connection ID.
     * @return A proxy with the specified connection ID.
     **/
    @Override
    default ACKServicePrx ice_connectionId(String connectionId)
    {
        return (ACKServicePrx)_ice_connectionId(connectionId);
    }

    /**
     * Returns a proxy that is identical to this proxy, except it's a fixed proxy bound
     * the given connection.@param connection The fixed proxy connection.
     * @return A fixed proxy bound to the given connection.
     **/
    @Override
    default ACKServicePrx ice_fixed(com.zeroc.Ice.Connection connection)
    {
        return (ACKServicePrx)_ice_fixed(connection);
    }

    static String ice_staticId()
    {
        return "::reliableMessage::ACKService";
    }
}


================================================================================
FILE: C:\Users\alexd\Universidad\SextoSemestre\Compunet\SistemaVotacion\reliableServer\build\generated-src\reliableMessage\RMDestination.java
--------------------------------------------------------------------------------
//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.10
//
// <auto-generated>
//
// Generated from file `ReliableMessage.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

package reliableMessage;

public interface RMDestination extends com.zeroc.Ice.Object
{
    void reciveMessage(model.ReliableMessage rmessage, ACKServicePrx prx, com.zeroc.Ice.Current current);

    /** @hidden */
    static final String[] _iceIds =
    {
        "::Ice::Object",
        "::reliableMessage::RMDestination"
    };

    @Override
    default String[] ice_ids(com.zeroc.Ice.Current current)
    {
        return _iceIds;
    }

    @Override
    default String ice_id(com.zeroc.Ice.Current current)
    {
        return ice_staticId();
    }

    static String ice_staticId()
    {
        return "::reliableMessage::RMDestination";
    }

    /**
     * @hidden
     * @param obj -
     * @param inS -
     * @param current -
     * @return -
    **/
    static java.util.concurrent.CompletionStage<com.zeroc.Ice.OutputStream> _iceD_reciveMessage(RMDestination obj, final com.zeroc.IceInternal.Incoming inS, com.zeroc.Ice.Current current)
    {
        com.zeroc.Ice.Object._iceCheckMode(null, current.mode);
        com.zeroc.Ice.InputStream istr = inS.startReadParams();
        model.ReliableMessage iceP_rmessage;
        ACKServicePrx iceP_prx;
        iceP_rmessage = istr.readSerializable(model.ReliableMessage.class);
        iceP_prx = ACKServicePrx.uncheckedCast(istr.readProxy());
        inS.endReadParams();
        obj.reciveMessage(iceP_rmessage, iceP_prx, current);
        return inS.setResult(inS.writeEmptyParams());
    }

    /** @hidden */
    final static String[] _iceOps =
    {
        "ice_id",
        "ice_ids",
        "ice_isA",
        "ice_ping",
        "reciveMessage"
    };

    /** @hidden */
    @Override
    default java.util.concurrent.CompletionStage<com.zeroc.Ice.OutputStream> _iceDispatch(com.zeroc.IceInternal.Incoming in, com.zeroc.Ice.Current current)
        throws com.zeroc.Ice.UserException
    {
        int pos = java.util.Arrays.binarySearch(_iceOps, current.operation);
        if(pos < 0)
        {
            throw new com.zeroc.Ice.OperationNotExistException(current.id, current.facet, current.operation);
        }

        switch(pos)
        {
            case 0:
            {
                return com.zeroc.Ice.Object._iceD_ice_id(this, in, current);
            }
            case 1:
            {
                return com.zeroc.Ice.Object._iceD_ice_ids(this, in, current);
            }
            case 2:
            {
                return com.zeroc.Ice.Object._iceD_ice_isA(this, in, current);
            }
            case 3:
            {
                return com.zeroc.Ice.Object._iceD_ice_ping(this, in, current);
            }
            case 4:
            {
                return _iceD_reciveMessage(this, in, current);
            }
        }

        assert(false);
        throw new com.zeroc.Ice.OperationNotExistException(current.id, current.facet, current.operation);
    }
}


================================================================================
FILE: C:\Users\alexd\Universidad\SextoSemestre\Compunet\SistemaVotacion\reliableServer\build\generated-src\reliableMessage\RMDestinationPrx.java
--------------------------------------------------------------------------------
//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.10
//
// <auto-generated>
//
// Generated from file `ReliableMessage.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

package reliableMessage;

public interface RMDestinationPrx extends com.zeroc.Ice.ObjectPrx
{
    default void reciveMessage(model.ReliableMessage rmessage, ACKServicePrx prx)
    {
        reciveMessage(rmessage, prx, com.zeroc.Ice.ObjectPrx.noExplicitContext);
    }

    default void reciveMessage(model.ReliableMessage rmessage, ACKServicePrx prx, java.util.Map<String, String> context)
    {
        _iceI_reciveMessageAsync(rmessage, prx, context, true).waitForResponse();
    }

    default java.util.concurrent.CompletableFuture<Void> reciveMessageAsync(model.ReliableMessage rmessage, ACKServicePrx prx)
    {
        return _iceI_reciveMessageAsync(rmessage, prx, com.zeroc.Ice.ObjectPrx.noExplicitContext, false);
    }

    default java.util.concurrent.CompletableFuture<Void> reciveMessageAsync(model.ReliableMessage rmessage, ACKServicePrx prx, java.util.Map<String, String> context)
    {
        return _iceI_reciveMessageAsync(rmessage, prx, context, false);
    }

    /**
     * @hidden
     * @param iceP_rmessage -
     * @param iceP_prx -
     * @param context -
     * @param sync -
     * @return -
     **/
    default com.zeroc.IceInternal.OutgoingAsync<Void> _iceI_reciveMessageAsync(model.ReliableMessage iceP_rmessage, ACKServicePrx iceP_prx, java.util.Map<String, String> context, boolean sync)
    {
        com.zeroc.IceInternal.OutgoingAsync<Void> f = new com.zeroc.IceInternal.OutgoingAsync<>(this, "reciveMessage", null, sync, null);
        f.invoke(false, context, null, ostr -> {
                     ostr.writeSerializable(iceP_rmessage);
                     ostr.writeProxy(iceP_prx);
                 }, null);
        return f;
    }

    /**
     * Contacts the remote server to verify that the object implements this type.
     * Raises a local exception if a communication error occurs.
     * @param obj The untyped proxy.
     * @return A proxy for this type, or null if the object does not support this type.
     **/
    static RMDestinationPrx checkedCast(com.zeroc.Ice.ObjectPrx obj)
    {
        return com.zeroc.Ice.ObjectPrx._checkedCast(obj, ice_staticId(), RMDestinationPrx.class, _RMDestinationPrxI.class);
    }

    /**
     * Contacts the remote server to verify that the object implements this type.
     * Raises a local exception if a communication error occurs.
     * @param obj The untyped proxy.
     * @param context The Context map to send with the invocation.
     * @return A proxy for this type, or null if the object does not support this type.
     **/
    static RMDestinationPrx checkedCast(com.zeroc.Ice.ObjectPrx obj, java.util.Map<String, String> context)
    {
        return com.zeroc.Ice.ObjectPrx._checkedCast(obj, context, ice_staticId(), RMDestinationPrx.class, _RMDestinationPrxI.class);
    }

    /**
     * Contacts the remote server to verify that a facet of the object implements this type.
     * Raises a local exception if a communication error occurs.
     * @param obj The untyped proxy.
     * @param facet The name of the desired facet.
     * @return A proxy for this type, or null if the object does not support this type.
     **/
    static RMDestinationPrx checkedCast(com.zeroc.Ice.ObjectPrx obj, String facet)
    {
        return com.zeroc.Ice.ObjectPrx._checkedCast(obj, facet, ice_staticId(), RMDestinationPrx.class, _RMDestinationPrxI.class);
    }

    /**
     * Contacts the remote server to verify that a facet of the object implements this type.
     * Raises a local exception if a communication error occurs.
     * @param obj The untyped proxy.
     * @param facet The name of the desired facet.
     * @param context The Context map to send with the invocation.
     * @return A proxy for this type, or null if the object does not support this type.
     **/
    static RMDestinationPrx checkedCast(com.zeroc.Ice.ObjectPrx obj, String facet, java.util.Map<String, String> context)
    {
        return com.zeroc.Ice.ObjectPrx._checkedCast(obj, facet, context, ice_staticId(), RMDestinationPrx.class, _RMDestinationPrxI.class);
    }

    /**
     * Downcasts the given proxy to this type without contacting the remote server.
     * @param obj The untyped proxy.
     * @return A proxy for this type.
     **/
    static RMDestinationPrx uncheckedCast(com.zeroc.Ice.ObjectPrx obj)
    {
        return com.zeroc.Ice.ObjectPrx._uncheckedCast(obj, RMDestinationPrx.class, _RMDestinationPrxI.class);
    }

    /**
     * Downcasts the given proxy to this type without contacting the remote server.
     * @param obj The untyped proxy.
     * @param facet The name of the desired facet.
     * @return A proxy for this type.
     **/
    static RMDestinationPrx uncheckedCast(com.zeroc.Ice.ObjectPrx obj, String facet)
    {
        return com.zeroc.Ice.ObjectPrx._uncheckedCast(obj, facet, RMDestinationPrx.class, _RMDestinationPrxI.class);
    }

    /**
     * Returns a proxy that is identical to this proxy, except for the per-proxy context.
     * @param newContext The context for the new proxy.
     * @return A proxy with the specified per-proxy context.
     **/
    @Override
    default RMDestinationPrx ice_context(java.util.Map<String, String> newContext)
    {
        return (RMDestinationPrx)_ice_context(newContext);
    }

    /**
     * Returns a proxy that is identical to this proxy, except for the adapter ID.
     * @param newAdapterId The adapter ID for the new proxy.
     * @return A proxy with the specified adapter ID.
     **/
    @Override
    default RMDestinationPrx ice_adapterId(String newAdapterId)
    {
        return (RMDestinationPrx)_ice_adapterId(newAdapterId);
    }

    /**
     * Returns a proxy that is identical to this proxy, except for the endpoints.
     * @param newEndpoints The endpoints for the new proxy.
     * @return A proxy with the specified endpoints.
     **/
    @Override
    default RMDestinationPrx ice_endpoints(com.zeroc.Ice.Endpoint[] newEndpoints)
    {
        return (RMDestinationPrx)_ice_endpoints(newEndpoints);
    }

    /**
     * Returns a proxy that is identical to this proxy, except for the locator cache timeout.
     * @param newTimeout The new locator cache timeout (in seconds).
     * @return A proxy with the specified locator cache timeout.
     **/
    @Override
    default RMDestinationPrx ice_locatorCacheTimeout(int newTimeout)
    {
        return (RMDestinationPrx)_ice_locatorCacheTimeout(newTimeout);
    }

    /**
     * Returns a proxy that is identical to this proxy, except for the invocation timeout.
     * @param newTimeout The new invocation timeout (in seconds).
     * @return A proxy with the specified invocation timeout.
     **/
    @Override
    default RMDestinationPrx ice_invocationTimeout(int newTimeout)
    {
        return (RMDestinationPrx)_ice_invocationTimeout(newTimeout);
    }

    /**
     * Returns a proxy that is identical to this proxy, except for connection caching.
     * @param newCache <code>true</code> if the new proxy should cache connections; <code>false</code> otherwise.
     * @return A proxy with the specified caching policy.
     **/
    @Override
    default RMDestinationPrx ice_connectionCached(boolean newCache)
    {
        return (RMDestinationPrx)_ice_connectionCached(newCache);
    }

    /**
     * Returns a proxy that is identical to this proxy, except for the endpoint selection policy.
     * @param newType The new endpoint selection policy.
     * @return A proxy with the specified endpoint selection policy.
     **/
    @Override
    default RMDestinationPrx ice_endpointSelection(com.zeroc.Ice.EndpointSelectionType newType)
    {
        return (RMDestinationPrx)_ice_endpointSelection(newType);
    }

    /**
     * Returns a proxy that is identical to this proxy, except for how it selects endpoints.
     * @param b If <code>b</code> is <code>true</code>, only endpoints that use a secure transport are
     * used by the new proxy. If <code>b</code> is false, the returned proxy uses both secure and
     * insecure endpoints.
     * @return A proxy with the specified selection policy.
     **/
    @Override
    default RMDestinationPrx ice_secure(boolean b)
    {
        return (RMDestinationPrx)_ice_secure(b);
    }

    /**
     * Returns a proxy that is identical to this proxy, except for the encoding used to marshal parameters.
     * @param e The encoding version to use to marshal request parameters.
     * @return A proxy with the specified encoding version.
     **/
    @Override
    default RMDestinationPrx ice_encodingVersion(com.zeroc.Ice.EncodingVersion e)
    {
        return (RMDestinationPrx)_ice_encodingVersion(e);
    }

    /**
     * Returns a proxy that is identical to this proxy, except for its endpoint selection policy.
     * @param b If <code>b</code> is <code>true</code>, the new proxy will use secure endpoints for invocations
     * and only use insecure endpoints if an invocation cannot be made via secure endpoints. If <code>b</code> is
     * <code>false</code>, the proxy prefers insecure endpoints to secure ones.
     * @return A proxy with the specified selection policy.
     **/
    @Override
    default RMDestinationPrx ice_preferSecure(boolean b)
    {
        return (RMDestinationPrx)_ice_preferSecure(b);
    }

    /**
     * Returns a proxy that is identical to this proxy, except for the router.
     * @param router The router for the new proxy.
     * @return A proxy with the specified router.
     **/
    @Override
    default RMDestinationPrx ice_router(com.zeroc.Ice.RouterPrx router)
    {
        return (RMDestinationPrx)_ice_router(router);
    }

    /**
     * Returns a proxy that is identical to this proxy, except for the locator.
     * @param locator The locator for the new proxy.
     * @return A proxy with the specified locator.
     **/
    @Override
    default RMDestinationPrx ice_locator(com.zeroc.Ice.LocatorPrx locator)
    {
        return (RMDestinationPrx)_ice_locator(locator);
    }

    /**
     * Returns a proxy that is identical to this proxy, except for collocation optimization.
     * @param b <code>true</code> if the new proxy enables collocation optimization; <code>false</code> otherwise.
     * @return A proxy with the specified collocation optimization.
     **/
    @Override
    default RMDestinationPrx ice_collocationOptimized(boolean b)
    {
        return (RMDestinationPrx)_ice_collocationOptimized(b);
    }

    /**
     * Returns a proxy that is identical to this proxy, but uses twoway invocations.
     * @return A proxy that uses twoway invocations.
     **/
    @Override
    default RMDestinationPrx ice_twoway()
    {
        return (RMDestinationPrx)_ice_twoway();
    }

    /**
     * Returns a proxy that is identical to this proxy, but uses oneway invocations.
     * @return A proxy that uses oneway invocations.
     **/
    @Override
    default RMDestinationPrx ice_oneway()
    {
        return (RMDestinationPrx)_ice_oneway();
    }

    /**
     * Returns a proxy that is identical to this proxy, but uses batch oneway invocations.
     * @return A proxy that uses batch oneway invocations.
     **/
    @Override
    default RMDestinationPrx ice_batchOneway()
    {
        return (RMDestinationPrx)_ice_batchOneway();
    }

    /**
     * Returns a proxy that is identical to this proxy, but uses datagram invocations.
     * @return A proxy that uses datagram invocations.
     **/
    @Override
    default RMDestinationPrx ice_datagram()
    {
        return (RMDestinationPrx)_ice_datagram();
    }

    /**
     * Returns a proxy that is identical to this proxy, but uses batch datagram invocations.
     * @return A proxy that uses batch datagram invocations.
     **/
    @Override
    default RMDestinationPrx ice_batchDatagram()
    {
        return (RMDestinationPrx)_ice_batchDatagram();
    }

    /**
     * Returns a proxy that is identical to this proxy, except for compression.
     * @param co <code>true</code> enables compression for the new proxy; <code>false</code> disables compression.
     * @return A proxy with the specified compression setting.
     **/
    @Override
    default RMDestinationPrx ice_compress(boolean co)
    {
        return (RMDestinationPrx)_ice_compress(co);
    }

    /**
     * Returns a proxy that is identical to this proxy, except for its connection timeout setting.
     * @param t The connection timeout for the proxy in milliseconds.
     * @return A proxy with the specified timeout.
     **/
    @Override
    default RMDestinationPrx ice_timeout(int t)
    {
        return (RMDestinationPrx)_ice_timeout(t);
    }

    /**
     * Returns a proxy that is identical to this proxy, except for its connection ID.
     * @param connectionId The connection ID for the new proxy. An empty string removes the connection ID.
     * @return A proxy with the specified connection ID.
     **/
    @Override
    default RMDestinationPrx ice_connectionId(String connectionId)
    {
        return (RMDestinationPrx)_ice_connectionId(connectionId);
    }

    /**
     * Returns a proxy that is identical to this proxy, except it's a fixed proxy bound
     * the given connection.@param connection The fixed proxy connection.
     * @return A fixed proxy bound to the given connection.
     **/
    @Override
    default RMDestinationPrx ice_fixed(com.zeroc.Ice.Connection connection)
    {
        return (RMDestinationPrx)_ice_fixed(connection);
    }

    static String ice_staticId()
    {
        return "::reliableMessage::RMDestination";
    }
}


================================================================================
FILE: C:\Users\alexd\Universidad\SextoSemestre\Compunet\SistemaVotacion\reliableServer\build\generated-src\reliableMessage\RMSource.java
--------------------------------------------------------------------------------
//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.10
//
// <auto-generated>
//
// Generated from file `ReliableMessage.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

package reliableMessage;

public interface RMSource extends com.zeroc.Ice.Object
{
    void setServerProxy(RMDestinationPrx destination, com.zeroc.Ice.Current current);

    void sendMessage(model.Message msg, com.zeroc.Ice.Current current);

    /** @hidden */
    static final String[] _iceIds =
    {
        "::Ice::Object",
        "::reliableMessage::RMSource"
    };

    @Override
    default String[] ice_ids(com.zeroc.Ice.Current current)
    {
        return _iceIds;
    }

    @Override
    default String ice_id(com.zeroc.Ice.Current current)
    {
        return ice_staticId();
    }

    static String ice_staticId()
    {
        return "::reliableMessage::RMSource";
    }

    /**
     * @hidden
     * @param obj -
     * @param inS -
     * @param current -
     * @return -
    **/
    static java.util.concurrent.CompletionStage<com.zeroc.Ice.OutputStream> _iceD_setServerProxy(RMSource obj, final com.zeroc.IceInternal.Incoming inS, com.zeroc.Ice.Current current)
    {
        com.zeroc.Ice.Object._iceCheckMode(null, current.mode);
        com.zeroc.Ice.InputStream istr = inS.startReadParams();
        RMDestinationPrx iceP_destination;
        iceP_destination = RMDestinationPrx.uncheckedCast(istr.readProxy());
        inS.endReadParams();
        obj.setServerProxy(iceP_destination, current);
        return inS.setResult(inS.writeEmptyParams());
    }

    /**
     * @hidden
     * @param obj -
     * @param inS -
     * @param current -
     * @return -
    **/
    static java.util.concurrent.CompletionStage<com.zeroc.Ice.OutputStream> _iceD_sendMessage(RMSource obj, final com.zeroc.IceInternal.Incoming inS, com.zeroc.Ice.Current current)
    {
        com.zeroc.Ice.Object._iceCheckMode(null, current.mode);
        com.zeroc.Ice.InputStream istr = inS.startReadParams();
        model.Message iceP_msg;
        iceP_msg = istr.readSerializable(model.Message.class);
        inS.endReadParams();
        obj.sendMessage(iceP_msg, current);
        return inS.setResult(inS.writeEmptyParams());
    }

    /** @hidden */
    final static String[] _iceOps =
    {
        "ice_id",
        "ice_ids",
        "ice_isA",
        "ice_ping",
        "sendMessage",
        "setServerProxy"
    };

    /** @hidden */
    @Override
    default java.util.concurrent.CompletionStage<com.zeroc.Ice.OutputStream> _iceDispatch(com.zeroc.IceInternal.Incoming in, com.zeroc.Ice.Current current)
        throws com.zeroc.Ice.UserException
    {
        int pos = java.util.Arrays.binarySearch(_iceOps, current.operation);
        if(pos < 0)
        {
            throw new com.zeroc.Ice.OperationNotExistException(current.id, current.facet, current.operation);
        }

        switch(pos)
        {
            case 0:
            {
                return com.zeroc.Ice.Object._iceD_ice_id(this, in, current);
            }
            case 1:
            {
                return com.zeroc.Ice.Object._iceD_ice_ids(this, in, current);
            }
            case 2:
            {
                return com.zeroc.Ice.Object._iceD_ice_isA(this, in, current);
            }
            case 3:
            {
                return com.zeroc.Ice.Object._iceD_ice_ping(this, in, current);
            }
            case 4:
            {
                return _iceD_sendMessage(this, in, current);
            }
            case 5:
            {
                return _iceD_setServerProxy(this, in, current);
            }
        }

        assert(false);
        throw new com.zeroc.Ice.OperationNotExistException(current.id, current.facet, current.operation);
    }
}


================================================================================
FILE: C:\Users\alexd\Universidad\SextoSemestre\Compunet\SistemaVotacion\reliableServer\build\generated-src\reliableMessage\RMSourcePrx.java
--------------------------------------------------------------------------------
//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.10
//
// <auto-generated>
//
// Generated from file `ReliableMessage.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

package reliableMessage;

public interface RMSourcePrx extends com.zeroc.Ice.ObjectPrx
{
    default void setServerProxy(RMDestinationPrx destination)
    {
        setServerProxy(destination, com.zeroc.Ice.ObjectPrx.noExplicitContext);
    }

    default void setServerProxy(RMDestinationPrx destination, java.util.Map<String, String> context)
    {
        _iceI_setServerProxyAsync(destination, context, true).waitForResponse();
    }

    default java.util.concurrent.CompletableFuture<Void> setServerProxyAsync(RMDestinationPrx destination)
    {
        return _iceI_setServerProxyAsync(destination, com.zeroc.Ice.ObjectPrx.noExplicitContext, false);
    }

    default java.util.concurrent.CompletableFuture<Void> setServerProxyAsync(RMDestinationPrx destination, java.util.Map<String, String> context)
    {
        return _iceI_setServerProxyAsync(destination, context, false);
    }

    /**
     * @hidden
     * @param iceP_destination -
     * @param context -
     * @param sync -
     * @return -
     **/
    default com.zeroc.IceInternal.OutgoingAsync<Void> _iceI_setServerProxyAsync(RMDestinationPrx iceP_destination, java.util.Map<String, String> context, boolean sync)
    {
        com.zeroc.IceInternal.OutgoingAsync<Void> f = new com.zeroc.IceInternal.OutgoingAsync<>(this, "setServerProxy", null, sync, null);
        f.invoke(false, context, null, ostr -> {
                     ostr.writeProxy(iceP_destination);
                 }, null);
        return f;
    }

    default void sendMessage(model.Message msg)
    {
        sendMessage(msg, com.zeroc.Ice.ObjectPrx.noExplicitContext);
    }

    default void sendMessage(model.Message msg, java.util.Map<String, String> context)
    {
        _iceI_sendMessageAsync(msg, context, true).waitForResponse();
    }

    default java.util.concurrent.CompletableFuture<Void> sendMessageAsync(model.Message msg)
    {
        return _iceI_sendMessageAsync(msg, com.zeroc.Ice.ObjectPrx.noExplicitContext, false);
    }

    default java.util.concurrent.CompletableFuture<Void> sendMessageAsync(model.Message msg, java.util.Map<String, String> context)
    {
        return _iceI_sendMessageAsync(msg, context, false);
    }

    /**
     * @hidden
     * @param iceP_msg -
     * @param context -
     * @param sync -
     * @return -
     **/
    default com.zeroc.IceInternal.OutgoingAsync<Void> _iceI_sendMessageAsync(model.Message iceP_msg, java.util.Map<String, String> context, boolean sync)
    {
        com.zeroc.IceInternal.OutgoingAsync<Void> f = new com.zeroc.IceInternal.OutgoingAsync<>(this, "sendMessage", null, sync, null);
        f.invoke(false, context, null, ostr -> {
                     ostr.writeSerializable(iceP_msg);
                 }, null);
        return f;
    }

    /**
     * Contacts the remote server to verify that the object implements this type.
     * Raises a local exception if a communication error occurs.
     * @param obj The untyped proxy.
     * @return A proxy for this type, or null if the object does not support this type.
     **/
    static RMSourcePrx checkedCast(com.zeroc.Ice.ObjectPrx obj)
    {
        return com.zeroc.Ice.ObjectPrx._checkedCast(obj, ice_staticId(), RMSourcePrx.class, _RMSourcePrxI.class);
    }

    /**
     * Contacts the remote server to verify that the object implements this type.
     * Raises a local exception if a communication error occurs.
     * @param obj The untyped proxy.
     * @param context The Context map to send with the invocation.
     * @return A proxy for this type, or null if the object does not support this type.
     **/
    static RMSourcePrx checkedCast(com.zeroc.Ice.ObjectPrx obj, java.util.Map<String, String> context)
    {
        return com.zeroc.Ice.ObjectPrx._checkedCast(obj, context, ice_staticId(), RMSourcePrx.class, _RMSourcePrxI.class);
    }

    /**
     * Contacts the remote server to verify that a facet of the object implements this type.
     * Raises a local exception if a communication error occurs.
     * @param obj The untyped proxy.
     * @param facet The name of the desired facet.
     * @return A proxy for this type, or null if the object does not support this type.
     **/
    static RMSourcePrx checkedCast(com.zeroc.Ice.ObjectPrx obj, String facet)
    {
        return com.zeroc.Ice.ObjectPrx._checkedCast(obj, facet, ice_staticId(), RMSourcePrx.class, _RMSourcePrxI.class);
    }

    /**
     * Contacts the remote server to verify that a facet of the object implements this type.
     * Raises a local exception if a communication error occurs.
     * @param obj The untyped proxy.
     * @param facet The name of the desired facet.
     * @param context The Context map to send with the invocation.
     * @return A proxy for this type, or null if the object does not support this type.
     **/
    static RMSourcePrx checkedCast(com.zeroc.Ice.ObjectPrx obj, String facet, java.util.Map<String, String> context)
    {
        return com.zeroc.Ice.ObjectPrx._checkedCast(obj, facet, context, ice_staticId(), RMSourcePrx.class, _RMSourcePrxI.class);
    }

    /**
     * Downcasts the given proxy to this type without contacting the remote server.
     * @param obj The untyped proxy.
     * @return A proxy for this type.
     **/
    static RMSourcePrx uncheckedCast(com.zeroc.Ice.ObjectPrx obj)
    {
        return com.zeroc.Ice.ObjectPrx._uncheckedCast(obj, RMSourcePrx.class, _RMSourcePrxI.class);
    }

    /**
     * Downcasts the given proxy to this type without contacting the remote server.
     * @param obj The untyped proxy.
     * @param facet The name of the desired facet.
     * @return A proxy for this type.
     **/
    static RMSourcePrx uncheckedCast(com.zeroc.Ice.ObjectPrx obj, String facet)
    {
        return com.zeroc.Ice.ObjectPrx._uncheckedCast(obj, facet, RMSourcePrx.class, _RMSourcePrxI.class);
    }

    /**
     * Returns a proxy that is identical to this proxy, except for the per-proxy context.
     * @param newContext The context for the new proxy.
     * @return A proxy with the specified per-proxy context.
     **/
    @Override
    default RMSourcePrx ice_context(java.util.Map<String, String> newContext)
    {
        return (RMSourcePrx)_ice_context(newContext);
    }

    /**
     * Returns a proxy that is identical to this proxy, except for the adapter ID.
     * @param newAdapterId The adapter ID for the new proxy.
     * @return A proxy with the specified adapter ID.
     **/
    @Override
    default RMSourcePrx ice_adapterId(String newAdapterId)
    {
        return (RMSourcePrx)_ice_adapterId(newAdapterId);
    }

    /**
     * Returns a proxy that is identical to this proxy, except for the endpoints.
     * @param newEndpoints The endpoints for the new proxy.
     * @return A proxy with the specified endpoints.
     **/
    @Override
    default RMSourcePrx ice_endpoints(com.zeroc.Ice.Endpoint[] newEndpoints)
    {
        return (RMSourcePrx)_ice_endpoints(newEndpoints);
    }

    /**
     * Returns a proxy that is identical to this proxy, except for the locator cache timeout.
     * @param newTimeout The new locator cache timeout (in seconds).
     * @return A proxy with the specified locator cache timeout.
     **/
    @Override
    default RMSourcePrx ice_locatorCacheTimeout(int newTimeout)
    {
        return (RMSourcePrx)_ice_locatorCacheTimeout(newTimeout);
    }

    /**
     * Returns a proxy that is identical to this proxy, except for the invocation timeout.
     * @param newTimeout The new invocation timeout (in seconds).
     * @return A proxy with the specified invocation timeout.
     **/
    @Override
    default RMSourcePrx ice_invocationTimeout(int newTimeout)
    {
        return (RMSourcePrx)_ice_invocationTimeout(newTimeout);
    }

    /**
     * Returns a proxy that is identical to this proxy, except for connection caching.
     * @param newCache <code>true</code> if the new proxy should cache connections; <code>false</code> otherwise.
     * @return A proxy with the specified caching policy.
     **/
    @Override
    default RMSourcePrx ice_connectionCached(boolean newCache)
    {
        return (RMSourcePrx)_ice_connectionCached(newCache);
    }

    /**
     * Returns a proxy that is identical to this proxy, except for the endpoint selection policy.
     * @param newType The new endpoint selection policy.
     * @return A proxy with the specified endpoint selection policy.
     **/
    @Override
    default RMSourcePrx ice_endpointSelection(com.zeroc.Ice.EndpointSelectionType newType)
    {
        return (RMSourcePrx)_ice_endpointSelection(newType);
    }

    /**
     * Returns a proxy that is identical to this proxy, except for how it selects endpoints.
     * @param b If <code>b</code> is <code>true</code>, only endpoints that use a secure transport are
     * used by the new proxy. If <code>b</code> is false, the returned proxy uses both secure and
     * insecure endpoints.
     * @return A proxy with the specified selection policy.
     **/
    @Override
    default RMSourcePrx ice_secure(boolean b)
    {
        return (RMSourcePrx)_ice_secure(b);
    }

    /**
     * Returns a proxy that is identical to this proxy, except for the encoding used to marshal parameters.
     * @param e The encoding version to use to marshal request parameters.
     * @return A proxy with the specified encoding version.
     **/
    @Override
    default RMSourcePrx ice_encodingVersion(com.zeroc.Ice.EncodingVersion e)
    {
        return (RMSourcePrx)_ice_encodingVersion(e);
    }

    /**
     * Returns a proxy that is identical to this proxy, except for its endpoint selection policy.
     * @param b If <code>b</code> is <code>true</code>, the new proxy will use secure endpoints for invocations
     * and only use insecure endpoints if an invocation cannot be made via secure endpoints. If <code>b</code> is
     * <code>false</code>, the proxy prefers insecure endpoints to secure ones.
     * @return A proxy with the specified selection policy.
     **/
    @Override
    default RMSourcePrx ice_preferSecure(boolean b)
    {
        return (RMSourcePrx)_ice_preferSecure(b);
    }

    /**
     * Returns a proxy that is identical to this proxy, except for the router.
     * @param router The router for the new proxy.
     * @return A proxy with the specified router.
     **/
    @Override
    default RMSourcePrx ice_router(com.zeroc.Ice.RouterPrx router)
    {
        return (RMSourcePrx)_ice_router(router);
    }

    /**
     * Returns a proxy that is identical to this proxy, except for the locator.
     * @param locator The locator for the new proxy.
     * @return A proxy with the specified locator.
     **/
    @Override
    default RMSourcePrx ice_locator(com.zeroc.Ice.LocatorPrx locator)
    {
        return (RMSourcePrx)_ice_locator(locator);
    }

    /**
     * Returns a proxy that is identical to this proxy, except for collocation optimization.
     * @param b <code>true</code> if the new proxy enables collocation optimization; <code>false</code> otherwise.
     * @return A proxy with the specified collocation optimization.
     **/
    @Override
    default RMSourcePrx ice_collocationOptimized(boolean b)
    {
        return (RMSourcePrx)_ice_collocationOptimized(b);
    }

    /**
     * Returns a proxy that is identical to this proxy, but uses twoway invocations.
     * @return A proxy that uses twoway invocations.
     **/
    @Override
    default RMSourcePrx ice_twoway()
    {
        return (RMSourcePrx)_ice_twoway();
    }

    /**
     * Returns a proxy that is identical to this proxy, but uses oneway invocations.
     * @return A proxy that uses oneway invocations.
     **/
    @Override
    default RMSourcePrx ice_oneway()
    {
        return (RMSourcePrx)_ice_oneway();
    }

    /**
     * Returns a proxy that is identical to this proxy, but uses batch oneway invocations.
     * @return A proxy that uses batch oneway invocations.
     **/
    @Override
    default RMSourcePrx ice_batchOneway()
    {
        return (RMSourcePrx)_ice_batchOneway();
    }

    /**
     * Returns a proxy that is identical to this proxy, but uses datagram invocations.
     * @return A proxy that uses datagram invocations.
     **/
    @Override
    default RMSourcePrx ice_datagram()
    {
        return (RMSourcePrx)_ice_datagram();
    }

    /**
     * Returns a proxy that is identical to this proxy, but uses batch datagram invocations.
     * @return A proxy that uses batch datagram invocations.
     **/
    @Override
    default RMSourcePrx ice_batchDatagram()
    {
        return (RMSourcePrx)_ice_batchDatagram();
    }

    /**
     * Returns a proxy that is identical to this proxy, except for compression.
     * @param co <code>true</code> enables compression for the new proxy; <code>false</code> disables compression.
     * @return A proxy with the specified compression setting.
     **/
    @Override
    default RMSourcePrx ice_compress(boolean co)
    {
        return (RMSourcePrx)_ice_compress(co);
    }

    /**
     * Returns a proxy that is identical to this proxy, except for its connection timeout setting.
     * @param t The connection timeout for the proxy in milliseconds.
     * @return A proxy with the specified timeout.
     **/
    @Override
    default RMSourcePrx ice_timeout(int t)
    {
        return (RMSourcePrx)_ice_timeout(t);
    }

    /**
     * Returns a proxy that is identical to this proxy, except for its connection ID.
     * @param connectionId The connection ID for the new proxy. An empty string removes the connection ID.
     * @return A proxy with the specified connection ID.
     **/
    @Override
    default RMSourcePrx ice_connectionId(String connectionId)
    {
        return (RMSourcePrx)_ice_connectionId(connectionId);
    }

    /**
     * Returns a proxy that is identical to this proxy, except it's a fixed proxy bound
     * the given connection.@param connection The fixed proxy connection.
     * @return A fixed proxy bound to the given connection.
     **/
    @Override
    default RMSourcePrx ice_fixed(com.zeroc.Ice.Connection connection)
    {
        return (RMSourcePrx)_ice_fixed(connection);
    }

    static String ice_staticId()
    {
        return "::reliableMessage::RMSource";
    }
}


================================================================================
FILE: C:\Users\alexd\Universidad\SextoSemestre\Compunet\SistemaVotacion\reliableServer\build\generated-src\reliableMessage\_ACKServicePrxI.java
--------------------------------------------------------------------------------
//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.10
//
// <auto-generated>
//
// Generated from file `ReliableMessage.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

package reliableMessage;

/** @hidden */
public class _ACKServicePrxI extends com.zeroc.Ice._ObjectPrxI implements ACKServicePrx
{
    /** @hidden */
    public static final long serialVersionUID = 0L;
}


================================================================================
FILE: C:\Users\alexd\Universidad\SextoSemestre\Compunet\SistemaVotacion\reliableServer\build\generated-src\reliableMessage\_RMDestinationPrxI.java
--------------------------------------------------------------------------------
//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.10
//
// <auto-generated>
//
// Generated from file `ReliableMessage.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

package reliableMessage;

/** @hidden */
public class _RMDestinationPrxI extends com.zeroc.Ice._ObjectPrxI implements RMDestinationPrx
{
    /** @hidden */
    public static final long serialVersionUID = 0L;
}


================================================================================
FILE: C:\Users\alexd\Universidad\SextoSemestre\Compunet\SistemaVotacion\reliableServer\build\generated-src\reliableMessage\_RMSourcePrxI.java
--------------------------------------------------------------------------------
//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.10
//
// <auto-generated>
//
// Generated from file `ReliableMessage.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

package reliableMessage;

/** @hidden */
public class _RMSourcePrxI extends com.zeroc.Ice._ObjectPrxI implements RMSourcePrx
{
    /** @hidden */
    public static final long serialVersionUID = 0L;
}


================================================================================
FILE: C:\Users\alexd\Universidad\SextoSemestre\Compunet\SistemaVotacion\reliableServer\build\resources\main\rmservice.config
--------------------------------------------------------------------------------
RMService.Endpoints=tcp -h localhost -p 10010

================================================================================
FILE: C:\Users\alexd\Universidad\SextoSemestre\Compunet\SistemaVotacion\reliableServer\src\main\java\ReliableServer.java
--------------------------------------------------------------------------------
import com.zeroc.Ice.Communicator;
import com.zeroc.Ice.ObjectAdapter;
import com.zeroc.Ice.ObjectPrx;
import com.zeroc.Ice.Util;

import communication.Notification;
import reliableMessage.ACKServicePrx;
import services.RMReciever;
import services.RMSender;
import threads.RMJob;

public class ReliableServer {
    
    public static void main(String[] args) {
        Communicator communicator = Util.initialize(args, "rmservice.config");

        Notification notification = new Notification();
        RMJob job = new RMJob(notification);
        RMReciever rec = new RMReciever(job);
        RMSender sender = new RMSender(job, notification);

        ObjectAdapter adapter = communicator.createObjectAdapter("RMService");
        adapter.add(sender, Util.stringToIdentity("Sender"));
        ObjectPrx prx = adapter.add(rec, Util.stringToIdentity("AckCallback"));
        notification.setAckService(ACKServicePrx.checkedCast(prx));
        adapter.activate();
        job.start();

        communicator.waitForShutdown();


        
    }

    
}


================================================================================
FILE: C:\Users\alexd\Universidad\SextoSemestre\Compunet\SistemaVotacion\reliableServer\src\main\java\communication\Notification.java
--------------------------------------------------------------------------------
package communication;

import model.ReliableMessage;
import reliableMessage.RMDestinationPrx;
import reliableMessage.ACKServicePrx;

public class Notification {

    private RMDestinationPrx service;

    private ACKServicePrx ackService;

    public void setAckService(ACKServicePrx ackService) {
        this.ackService = ackService;
    }

    public void setService(RMDestinationPrx service) {
        this.service = service;
    }

    

    public void sendMessage(ReliableMessage message){
        service.reciveMessage(message, ackService);
    }
}


================================================================================
FILE: C:\Users\alexd\Universidad\SextoSemestre\Compunet\SistemaVotacion\reliableServer\src\main\java\model\Message.java
--------------------------------------------------------------------------------
package model;

import java.io.Serializable;

public class Message implements Serializable {
    
    public String message;
}


================================================================================
FILE: C:\Users\alexd\Universidad\SextoSemestre\Compunet\SistemaVotacion\reliableServer\src\main\java\model\ReliableMessage.java
--------------------------------------------------------------------------------
package model;

import java.io.Serializable;

public class ReliableMessage implements Serializable{
    
    private String uuid;
    private long numberMessage;
    private String state;

    private Message message;

    public ReliableMessage(String uuid, long numberMessage, String state, Message message) {
        this.uuid = uuid;
        this.numberMessage = numberMessage;
        this.state = state;
        this.message = message;
    }

    public String getUuid() {
        return uuid;
    }

    public void setUuid(String uuid) {
        this.uuid = uuid;
    }

    public long getNumberMessage() {
        return numberMessage;
    }

    public void setNumberMessage(long numberMessage) {
        this.numberMessage = numberMessage;
    }

    public String getState() {
        return state;
    }

    public void setState(String state) {
        this.state = state;
    }

    public Message getMessage() {
        return message;
    }

    public void setMessage(Message message) {
        this.message = message;
    }
    
    
    
    
}


================================================================================
FILE: C:\Users\alexd\Universidad\SextoSemestre\Compunet\SistemaVotacion\reliableServer\src\main\java\services\RMReciever.java
--------------------------------------------------------------------------------
package services;

import com.zeroc.Ice.Current;

import reliableMessage.ACKService;
import threads.RMJob;

public class  RMReciever implements  ACKService {

    private RMJob jobM;

    

    public RMReciever(RMJob job) {
        this.jobM = job;
    }

    @Override
    public void ack(String messageId, Current current) {
        jobM.confirmMessage(messageId);
    }

    
    
}


================================================================================
FILE: C:\Users\alexd\Universidad\SextoSemestre\Compunet\SistemaVotacion\reliableServer\src\main\java\services\RMSender.java
--------------------------------------------------------------------------------
package services;

import com.zeroc.Ice.Current;

import communication.Notification;
import model.Message;
import reliableMessage.RMDestinationPrx;
import reliableMessage.RMSource;
import threads.RMJob;

public class RMSender implements RMSource{

    private RMJob jobM;
    private Notification notification;

    
    public RMSender(RMJob job, Notification not) {
        notification = not;
        jobM = job;
    }


    @Override
    public void sendMessage(Message msg, Current current) {
        jobM.add(msg);
    }
    @Override
    public void setServerProxy(RMDestinationPrx destination, Current current){
        notification.setService(destination);
    }


    
}


================================================================================
FILE: C:\Users\alexd\Universidad\SextoSemestre\Compunet\SistemaVotacion\reliableServer\src\main\java\threads\RMJob.java
--------------------------------------------------------------------------------
    package threads;

import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

import communication.Notification;
import model.Message;
import model.ReliableMessage;

public class RMJob extends Thread{

    public static final String PENDING = "Pending";
    public static final String SENDED = "Sended";

    private Map<String,ReliableMessage> messagesPendig = new ConcurrentHashMap<>();
    private Map<String,ReliableMessage> forConfirm = new ConcurrentHashMap<>();


    private Long sequenceNumber = 0l;
    private Object lock = new Object();
    private boolean enable = true;
    private Notification notification;

    public RMJob(Notification notification) {
        this.notification = notification;
    }

    public void add(Message message){
        synchronized (lock) {
            ReliableMessage mes = new ReliableMessage(UUID.randomUUID().toString(), sequenceNumber++, PENDING, message);
            messagesPendig.put(mes.getUuid(),mes);
        }
    }

    public void confirmMessage(String uid){
        forConfirm.remove(uid);
    }

    public void setEnable(boolean enable) {
        this.enable = enable;
    }

    @Override
    public void run(){
        while (enable) { 
            System.out.println("cicle");
            for(Map.Entry<String,ReliableMessage> rm: messagesPendig.entrySet()){
                try {
                    System.out.println("Sendig messge");
                    notification.sendMessage(rm.getValue());
                    messagesPendig.remove(rm.getKey());
                    forConfirm.put(rm.getKey(), rm.getValue());
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                Thread.sleep(10000);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
}


================================================================================
FILE: C:\Users\alexd\Universidad\SextoSemestre\Compunet\SistemaVotacion\reliableServer\src\main\resources\rmservice.config
--------------------------------------------------------------------------------
RMService.Endpoints=tcp -h localhost -p 10010

